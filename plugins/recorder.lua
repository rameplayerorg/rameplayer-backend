local plutils = require 'pl.utils'
local cqueues = require 'cqueues'
local posix = require 'posix'
local process = require 'cqp.process'
local RAME = require 'rame.rame'

-- wait time in secs to check bmd-streamer is still running
local WAIT_PROCESS = 1
local BMD_STREAMER = "/usr/bin/bmd-streamer"
local SCRIPT_PATH = "/etc/bmd-streamer/ffmpeg.sh"

local function pexec(...)
	return process.popen(...):read_all()
end

-- Plugin Hooks
local Plugin = {}

Plugin.streaming = false
Plugin.recording = false

-- REST API: /recorder/
local RECORDER = { GET = {}, PUT = {} }

-- Generates ffmpeg script to be launched by bmd-stream
local function gen_script(cfg)
	local c = [[#!/bin/sh
# auto-generated by RamePlayer
exec /usr/bin/ffmpeg -fflags +genpts -i - -bsf:a aac_adtstoasc]]

	if cfg.recorderEnabled then
		c = c .. " \\\n\t-codec:a copy -codec:v copy \"" .. cfg.recordingPath .. "\""
	end

	if cfg.streamingEnabled then
		if cfg.streamNum == "1" then
			c = c .. " \\\n\t-f flv -codec:a copy -codec:v copy rtmp://localhost/rame/program"
		elseif cfg.streamNum == "2" then
			c = c .. " \\\n\t-f flv -codec:v copy -strict experimental -codec:a aac -b:a 256k -af \"pan=1c|c0=c0\" rtmp://localhost/rame/audio1"
			c = c .. " \\\n\t-f flv -codec:v copy -strict experimental -codec:a aac -b:a 256k -af \"pan=1c|c0=c1\" rtmp://localhost/rame/audio2"
		end
	end
	return c .. "\n"
end

local function write_script(data)
	plutils.writefile(SCRIPT_PATH, data)
	posix.chmod(SCRIPT_PATH, "rwxrwxrwx")
end

-- Starts bmd-streamer
local function start_process(cfg)
	RAME.recorder.running(true)
	if cfg.recorderEnabled then
		Plugin.recording = true
		RAME.recorder.recording(true)
	end
	if cfg.streamingEnabled then
		Plugin.streaming = true
		RAME.recorder.streaming(true)
	end

	write_script(gen_script(cfg))

	local cmd = {
		"/usr/bin/bmd-streamer",
		"-S", cfg.input,
		"--syslog",
		"--firmware-dir", "/etc/bmd-streamer",
		"--exec", SCRIPT_PATH,
		"--video-kbps", "" .. (cfg.bitrate - 100),
		"--video-max-kbps", "" .. cfg.bitrate,
		"--h264-profile", "main",
		"--h264-level", "32",
		"--h264-no-bframes"
	}
	Plugin.process = process.spawn(table.unpack(cmd))
	cqueues.running():wrap(function()
		-- wait until process is terminated
		local status = Plugin.process:wait()
		RAME.log.info(('bmd-streamer terminated: %d'):format(status))
		RAME.recorder.running(false)
		RAME.recorder.recording(false)
		RAME.recorder.streaming(false)
		Plugin.recording = false
		Plugin.streaming = false
		Plugin.process = nil
	end)

	-- wait to see if running flag has changed
	cqueues.poll(WAIT_PROCESS)
	RAME.log.info('bmd-streamer is running')
	return RAME.recorder.running()
end

function RECORDER.GET.config()
	return 200, {}
end

function RECORDER.PUT.start(ctx, reply)
	local cfg = ctx.args

	-- validate request
	err, msg = RAME.check_fields(cfg, {
		bitrate          = {typeof="number"},
		input            = {typeof="string"},
		recorderEnabled  = {typeof="boolean"},
		recordingPath    = {typeof="string"},
		streamingEnabled = {typeof="boolean"},
		streamNum        = {typeof="string"}
	})
	if err then return err, msg end

	if Plugin.streaming or Plugin.recording then
		return 503, { error = "bmd-streamer already running" }
	end

	if start_process(cfg) then
		return 200, {}
	else
		return 500, { error = "bmd-streamer not started" }
	end
end

function RECORDER.GET.stop(ctx, reply)
	if Plugin.process then
		RAME.log.debug('stop streaming/recording')
		Plugin.process:kill(9)
		return 200, {}
	end
	return 500, { error = "bmd-streamer was not running" }
end

function Plugin.init()
	RAME.recorder.enabled(true)
	RAME.rest.recorder = function(ctx, reply) return ctx:route(reply, RECORDER) end
end

return Plugin
